from __future__ import annotations

import os
import pathlib
import random
import string
import sys
import threading
import time
import traceback
import typing
import uuid
from collections import defaultdict
from concurrent.futures import Future
from dataclasses import dataclass
from decimal import Decimal
from typing import TYPE_CHECKING

import sdc11073
from pat.ReferenceTestV2.consumer import result_collector
from sdc11073 import network, observableproperties
from sdc11073.consumer.serviceclients import contextservice
from sdc11073.mdib import descriptorcontainers, statecontainers
from sdc11073.observableproperties import observables
from sdc11073.certloader import mk_ssl_contexts_from_folder
from sdc11073.consumer import SdcConsumer, operations
from sdc11073.definitions_sdc import SdcV1Definitions
from sdc11073.mdib.consumermdib import ConsumerMdib
from sdc11073.mdib.consumermdibxtra import ConsumerMdibMethods
from sdc11073.wsdiscovery import WSDiscovery
from sdc11073.xml_types import msg_types, pm_qnames, pm_types, actions

def evaluate_operation_result(future: Future[operations.OperationResult], step, info, results_collector, timeout: float = 5.0) -> bool:
    operation_result = future.result(timeout)
    if operation_result.InvocationInfo.InvocationState == msg_types.InvocationState.FINISHED:
        return True
    results_collector.log_result(
        False,
        step,
        info,
        f'got result {operation_result.InvocationInfo.InvocationState} '
        f'{operation_result.InvocationInfo.InvocationError} '
        f'{operation_result.InvocationInfo.InvocationErrorMessage}',
    )
    return False

def test_6b(client: SdcConsumer, mdib: ConsumerMdib, results_collector: result_collector.ResultsCollector):
    set_context_state_handle = 'set_context_0.sco.mds_0'
    step = '6b'
    info = 'SetContextState'
    print(step, info)
    patient_context_descriptors: list[descriptorcontainers.PatientContextDescriptorContainer] = mdib.descriptions.NODETYPE.get(pm_qnames.PatientContextDescriptor, [])
    if not patient_context_descriptors:
        results_collector.log_result(False, step, info, extra_info='no PatientContextDescriptor')
        return
    generated_family_names = []
    context_service: contextservice.ContextServiceClient = typing.cast('contextservice.ContextServiceClient', client.context_service_client)
    for p in patient_context_descriptors:
        for association in list(pm_types.ContextAssociation):
            pat: statecontainers.PatientContextStateContainer = typing.cast('statecontainers.PatientContextStateContainer', context_service.mk_proposed_context_object(p.Handle))
            pat.CoreData.Familyname = uuid.uuid4().hex
            pat.ContextAssociation = association
            generated_family_names.append(pat.CoreData.Familyname)

            event = threading.Event()
            def _on_context_state(updates: dict[str, statecontainers.AbstractContextStateContainer]):
                # handle will be generated by provider
                for state in (s for s in updates.values() if s.DescriptorHandle == p.Handle):
                    print(f'context state updated: {state}')
                    if state.ContextAssociation == association:
                        if isinstance(state, statecontainers.PatientContextStateContainer):
                            if state.CoreData.Familyname == pat.CoreData.Familyname:
                                print(f'new patient {pat.CoreData.Familyname} is {association}')
                                event.set()
            with observables.bound_context(mdib, context_by_handle=_on_context_state):
                fut: Future = context_service.set_context_state(set_context_state_handle, [pat])
                if evaluate_operation_result(fut, step, info, results_collector):
                    results_collector.log_result(
                        event.wait(10.0),
                        step,
                        info,
                        extra_info=f'new patient {pat.CoreData.Familyname} is {association}',
                    )

    time.sleep(1)  # allow update notification to arrive
    patients = mdib.context_states.NODETYPE.get(pm_qnames.PatientContextState, [])
    if len(patients) == 0:
        results_collector.log_result(False, step, info, extra_info='no patients found')
    else:
        all_ok = True
        for patient in patients:
            if patient.CoreData.Familyname in generated_family_names:
                if patient.ContextAssociation != pm_types.ContextAssociation.ASSOCIATED:
                    results_collector.log_result(
                        False,
                        step,
                        info,
                        extra_info=f'new patient {patient.CoreData.Familyname} is {patient.ContextAssociation}',
                    )
                    all_ok = False
            elif patient.ContextAssociation == pm_types.ContextAssociation.ASSOCIATED:
                results_collector.log_result(
                    False,
                    step,
                    info,
                    extra_info=f'old patient {patient.CoreData.Familyname} is {patient.ContextAssociation}',
                )
                all_ok = False
        results_collector.log_result(all_ok, step, info)
